<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>查询 | sqala</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="类型安全的Scala3查询库">
    
    <link rel="preload" href="/sqala-doc/assets/css/0.styles.41638646.css" as="style"><link rel="preload" href="/sqala-doc/assets/js/app.96be3cda.js" as="script"><link rel="preload" href="/sqala-doc/assets/js/2.767acac5.js" as="script"><link rel="preload" href="/sqala-doc/assets/js/1.7485bcf3.js" as="script"><link rel="preload" href="/sqala-doc/assets/js/31.25a10860.js" as="script"><link rel="prefetch" href="/sqala-doc/assets/js/10.c454cbf7.js"><link rel="prefetch" href="/sqala-doc/assets/js/11.4c11b429.js"><link rel="prefetch" href="/sqala-doc/assets/js/12.37c67b2d.js"><link rel="prefetch" href="/sqala-doc/assets/js/13.bf4c6df4.js"><link rel="prefetch" href="/sqala-doc/assets/js/14.a15beb18.js"><link rel="prefetch" href="/sqala-doc/assets/js/15.dd179505.js"><link rel="prefetch" href="/sqala-doc/assets/js/16.14fa32d7.js"><link rel="prefetch" href="/sqala-doc/assets/js/17.65f688a3.js"><link rel="prefetch" href="/sqala-doc/assets/js/18.9a514804.js"><link rel="prefetch" href="/sqala-doc/assets/js/19.254801e4.js"><link rel="prefetch" href="/sqala-doc/assets/js/20.1410a88d.js"><link rel="prefetch" href="/sqala-doc/assets/js/21.ea553156.js"><link rel="prefetch" href="/sqala-doc/assets/js/22.ce2cea28.js"><link rel="prefetch" href="/sqala-doc/assets/js/23.12db8fd2.js"><link rel="prefetch" href="/sqala-doc/assets/js/24.410416e3.js"><link rel="prefetch" href="/sqala-doc/assets/js/25.08da704b.js"><link rel="prefetch" href="/sqala-doc/assets/js/26.9367b22d.js"><link rel="prefetch" href="/sqala-doc/assets/js/27.7946b464.js"><link rel="prefetch" href="/sqala-doc/assets/js/28.5e72bf29.js"><link rel="prefetch" href="/sqala-doc/assets/js/29.955fe444.js"><link rel="prefetch" href="/sqala-doc/assets/js/3.25337f94.js"><link rel="prefetch" href="/sqala-doc/assets/js/30.ab9f1f37.js"><link rel="prefetch" href="/sqala-doc/assets/js/32.1177fae6.js"><link rel="prefetch" href="/sqala-doc/assets/js/33.a01a8fc8.js"><link rel="prefetch" href="/sqala-doc/assets/js/4.0dfa8901.js"><link rel="prefetch" href="/sqala-doc/assets/js/5.28a50498.js"><link rel="prefetch" href="/sqala-doc/assets/js/6.f25848c6.js"><link rel="prefetch" href="/sqala-doc/assets/js/7.3ac2c704.js"><link rel="prefetch" href="/sqala-doc/assets/js/vendors~docsearch.8b826ef6.js">
    <link rel="stylesheet" href="/sqala-doc/assets/css/0.styles.41638646.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sqala-doc/" class="home-link router-link-active"><!----> <span class="site-name">sqala</span></a> <div class="links"><!----> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/sqala-doc/metadata/" class="sidebar-link">元数据配置</a></li><li><a href="/sqala-doc/database/" class="sidebar-link">数据库交互</a></li><li><a href="/sqala-doc/query/" aria-current="page" class="active sidebar-link">查询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sqala-doc/query/#构建查询" class="sidebar-link">构建查询</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#投影" class="sidebar-link">投影</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#过滤" class="sidebar-link">过滤</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#高级过滤" class="sidebar-link">高级过滤</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#使用for推导式" class="sidebar-link">使用for推导式</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#限制结果集" class="sidebar-link">限制结果集</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#表连接" class="sidebar-link">表连接</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#分组" class="sidebar-link">分组</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#distincton分组" class="sidebar-link">distinctOn分组</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#排序" class="sidebar-link">排序</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#去重" class="sidebar-link">去重</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#子查询" class="sidebar-link">子查询</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#集合操作" class="sidebar-link">集合操作</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#从内存集合创建查询" class="sidebar-link">从内存集合创建查询</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#函数表" class="sidebar-link">函数表</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#递归查询" class="sidebar-link">递归查询</a></li><li class="sidebar-sub-header"><a href="/sqala-doc/query/#透视表" class="sidebar-link">透视表</a></li></ul></li><li><a href="/sqala-doc/native-query/" class="sidebar-link">原生SQL</a></li><li><a href="/sqala-doc/expr/" class="sidebar-link">表达式</a></li><li><a href="/sqala-doc/example/" class="sidebar-link">示例</a></li><li><a href="/sqala-doc/update/" class="sidebar-link">增删改</a></li><li><a href="/sqala-doc/dynamic-query/" class="sidebar-link">动态查询构造</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="查询"><a href="#查询" class="header-anchor">#</a> 查询</h1> <p>在配置好元数据之后，我们就可以开始着手构建查询了，sqala使用类似Scala集合库风格的api创建查询。</p> <p>以下用法均需要导入：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">import</span> <span class="token namespace">sqala<span class="token punctuation">.</span>static<span class="token punctuation">.</span>dsl<span class="token punctuation">.</span></span><span class="token operator">*</span>
<span class="token keyword">import</span> <span class="token namespace">sqala<span class="token punctuation">.</span>static<span class="token punctuation">.</span>dsl<span class="token punctuation">.</span>given</span>
</code></pre></div><h2 id="构建查询"><a href="#构建查询" class="header-anchor">#</a> 构建查询</h2> <p>sqala的查询需要放在<code>queryContext</code>方法中构建，改方法提供了构造查询需要的上下文。</p> <p>使用<code>query</code>方法构建，其类型参数是实体类的名称：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
</code></pre></div><p>其生成的SQL（以MySQL方言为例）形如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
    <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>gender<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>id_number<span class="token punctuation">`</span></span>
<span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span>
</code></pre></div><p>查询返回的数据类型为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> List<span class="token punctuation">[</span>People<span class="token punctuation">]</span> <span class="token operator">=</span> db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div><h2 id="投影"><a href="#投影" class="header-anchor">#</a> 投影</h2> <p>使用<code>map</code>方法进行结果集的投影操作，其对应到SQL的<code>SELECT</code>子句，参数是一个表结构对象映射到的<a href="https://wz7982.github.io/sqala-doc/expr/" target="_blank" rel="noopener noreferrer">表达式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>及其组成的<code>元组</code>或<code>命名元组</code>：</p> <h3 id="投影到表达式"><a href="#投影到表达式" class="header-anchor">#</a> 投影到表达式</h3> <p>sqala支持投影到字段等表达式：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">import</span> <span class="token namespace">sqala<span class="token punctuation">.</span>static<span class="token punctuation">.</span>dsl<span class="token punctuation">.</span></span><span class="token operator">*</span>

<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>查询返回数据为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div><h3 id="投影到元组"><a href="#投影到元组" class="header-anchor">#</a> 投影到元组</h3> <p>sqala支持投影到表和表达式组成的元组：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">import</span> <span class="token namespace">sqala<span class="token punctuation">.</span>static<span class="token punctuation">.</span>dsl<span class="token punctuation">.</span></span><span class="token operator">*</span>

<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>查询返回数据为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div><h3 id="投影到命名元组"><a href="#投影到命名元组" class="header-anchor">#</a> 投影到命名元组</h3> <p>命名元组（NamedTuple）是Scala3.6的新特性，投影到命名元组可以更加明确查询的目的，并且在返回结果集中可以使用<code>.</code>直接调用其中的字段，而无需另行创建实体类接收中间结果。</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">import</span> <span class="token namespace">sqala<span class="token punctuation">.</span>static<span class="token punctuation">.</span>dsl<span class="token punctuation">.</span></span><span class="token operator">*</span>

<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>查询返回数据为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div><p>我们可以直接使用<code>.</code>调用其中字段：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">for</span> r <span class="token keyword">&lt;-</span> result <span class="token keyword">do</span>
    println<span class="token punctuation">(</span>r<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
    println<span class="token punctuation">(</span>r<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre></div><h3 id="投影的限制"><a href="#投影的限制" class="header-anchor">#</a> 投影的限制</h3> <p>在未分组的查询中，如果投影中同时出现了聚合函数和非聚合函数表达式，如：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>将会得到编译错误。sqala会在编译期解析参数，进行语义分析，拦截错误查询。</p> <h2 id="过滤"><a href="#过滤" class="header-anchor">#</a> 过滤</h2> <p>使用<code>filter</code>方法进行条件过滤，其对应到SQL的<code>WHERE</code>子句，参数是一个<code>Boolean</code>类型的<a href="https://wz7982.github.io/sqala-doc/expr/" target="_blank" rel="noopener noreferrer">表达式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> id <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>其生成的SQL（以MySQL方言为例）形如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span>
<span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span>
<span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">=</span> ?
</code></pre></div><p><strong>多次调用<code>filter</code>时将会使用AND来连接查询条件。</strong></p> <p>对于动态拼接的条件，sqala提供了<code>filterIf</code>方法，会在第一个参数值为<code>true</code>时使用<code>AND</code>将条件拼接到查询中：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> id <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">val</span> name <span class="token operator">=</span> <span class="token string">&quot;小黑&quot;</span>

<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>filterIf<span class="token punctuation">(</span>id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">.</span>filterIf<span class="token punctuation">(</span>name<span class="token punctuation">.</span>nonEmpty<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>name <span class="token operator">==</span> name<span class="token punctuation">)</span>
</code></pre></div><p><strong><code>filter</code>不会改变查询结果类型。</strong></p> <h3 id="过滤条件的限制"><a href="#过滤条件的限制" class="header-anchor">#</a> 过滤条件的限制</h3> <p>在<code>filter</code>中的表达式如果包含聚合函数、窗口函数等情况，将产生编译错误：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token comment">// 编译错误</span>
<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="高级过滤"><a href="#高级过滤" class="header-anchor">#</a> 高级过滤</h2> <p>由于数据库不允许<code>WHERE</code>中包含窗口函数或聚合函数，因此，sqala会在<code>filter</code>中使用窗口函数或聚合函数时产生编译错误，以此保证查询安全性，但我们可以使用<code>qualify</code>方法对数据投影后的结果再次过滤，而无需嵌套子查询：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> rank <span class="token operator">=</span> rank<span class="token punctuation">(</span><span class="token punctuation">)</span> over <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>qualify<span class="token punctuation">(</span>r <span class="token keyword">=&gt;</span> r<span class="token punctuation">.</span>rank <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>
</code></pre></div><p>考虑到并非所有数据库都实现了<code>QUALIFY</code>子句，因此，sqala在生成SQL时仍会生成子查询，并将<code>qualify</code>的条件视为外层查询的<code>WHERE</code>条件。</p> <h2 id="使用for推导式"><a href="#使用for推导式" class="header-anchor">#</a> 使用for推导式</h2> <p>只有过滤和投影操作的简单查询可以使用Scala的<code>for</code>推导式简化，比如以下查询：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre></div><p>可以简写成：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    <span class="token keyword">for</span> p <span class="token keyword">&lt;-</span> query<span class="token punctuation">[</span>People<span class="token punctuation">]</span> <span class="token keyword">if</span> p<span class="token punctuation">.</span>id <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">yield</span> p<span class="token punctuation">.</span>id
</code></pre></div><p>通常开发中最常使用的就是简单的查询，推荐写成<code>for</code>的形式以获取更好的可读性。</p> <h2 id="限制结果集"><a href="#限制结果集" class="header-anchor">#</a> 限制结果集</h2> <p><code>drop</code>和<code>take</code>方法用于限制结果集，对应到SQL的<code>OFFSET</code>和<code>LIMIT</code>等子句，sqala会自动进行方言适配：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span>take<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="表连接"><a href="#表连接" class="header-anchor">#</a> 表连接</h2> <p>sqala支持使用<code>join</code>、<code>leftJoin</code>、<code>rightJoin</code>来处理表连接，并使用<code>on</code>来处理连接条件：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>join<span class="token punctuation">[</span>B<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>id <span class="token operator">==</span> b<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>join<span class="token punctuation">[</span>C<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>id <span class="token operator">==</span> c<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre></div><p><code>on</code>引用的参数类型为一个由表对象组成的元组，元组项的数量会根据连接的表数量变化。</p> <p>此时返回的结果类型为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div><p><code>.on</code>可以省略，上面的查询可以简写成：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>join<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>id <span class="token operator">==</span> b<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>join<span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>id <span class="token operator">==</span> c<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre></div><p>由于外连接会产生额外的空值，因此，sqala可以从表连接的信息中自动推断返回类型，如果我们把上面的查询改为先进行右连接再进行左连接：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>rightJoin<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>id <span class="token operator">==</span> b<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>leftJoin<span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>id <span class="token operator">==</span> c<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre></div><p>此时返回的结果类型变成了：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token punctuation">(</span>Option<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> Option<span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div><p>这里显式写出了返回类型仅仅是为了演示，sqala会从查询中自动推断出合适的返回类型。</p> <p>我们也可以方便地处理连接自身的情况，比如有一个存储部门树的表对象：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">case</span> <span class="token keyword">class</span> Department<span class="token punctuation">(</span>
    id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span>
    managerId<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token builtin">String</span>
<span class="token punctuation">)</span>
</code></pre></div><p>我们可以这样来关联查询：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>Department<span class="token punctuation">]</span><span class="token punctuation">.</span>leftJoin<span class="token punctuation">[</span>Department<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> t1<span class="token punctuation">.</span>managerId <span class="token operator">==</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre></div><h2 id="分组"><a href="#分组" class="header-anchor">#</a> 分组</h2> <p>使用<code>groupBy</code>进行分组操作，参数是表达式组成的<strong>命名元组</strong>。</p> <p>在<code>groupBy</code>之后的<code>map</code>中，有两个参数，第一个是分组字段列表，第二个是原表：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> p<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>name <span class="token operator">=</span> g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birthday <span class="token operator">=</span> max<span class="token punctuation">(</span>p<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>其生成的SQL（以MySQL方言为例）形如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>gender<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>gender<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>count<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span>
<span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>gender<span class="token punctuation">`</span></span>
</code></pre></div><p>如果是多个对表连接的结果分组，则<code>map</code>的参数是一个元组，分组项作为元组第一项，两表连接的情况如下：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>join<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>x <span class="token operator">==</span> b<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>y1 <span class="token operator">=</span> a<span class="token punctuation">.</span>y<span class="token punctuation">,</span> y2 <span class="token operator">=</span> b<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>y1 <span class="token operator">=</span> g<span class="token punctuation">.</span>y1<span class="token punctuation">,</span> y2 <span class="token operator">=</span> g<span class="token punctuation">.</span>y2<span class="token punctuation">,</span> s1 <span class="token operator">=</span> sum<span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> sum<span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>三表连接的情况如下，以此类推：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>join<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>x <span class="token operator">==</span> b<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>join<span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>x <span class="token operator">==</span> c<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>y1 <span class="token operator">=</span> a<span class="token punctuation">.</span>y<span class="token punctuation">,</span> y2 <span class="token operator">=</span> b<span class="token punctuation">.</span>y<span class="token punctuation">,</span> y3 <span class="token operator">=</span> c<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> 
            <span class="token punctuation">(</span>y1 <span class="token operator">=</span> g<span class="token punctuation">.</span>y1<span class="token punctuation">,</span> y2 <span class="token operator">=</span> g<span class="token punctuation">.</span>y2<span class="token punctuation">,</span> y3 <span class="token operator">=</span> g<span class="token punctuation">.</span>y3<span class="token punctuation">,</span> s1 <span class="token operator">=</span> sum<span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> sum<span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> s3 <span class="token operator">=</span> sum<span class="token punctuation">(</span>c<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>分组使用有如下限制：</p> <ol><li>分组后的投影和排序等操作，必须是仅包含第一个参数引用的字段，或聚合函数组成的表达式。</li> <li><code>groupBy</code>中不能包含聚合函数或窗口函数。</li> <li><code>groupBy</code>中不能是值表达式。</li></ol> <p>以上情况均会产生编译错误。</p> <p>例如：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token comment">// 编译错误：分组后的投影无法引用字段a.x</span>
<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>a <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> a<span class="token punctuation">.</span>x <span class="token operator">+</span> a<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>将未分组字段加入到聚合函数中可以解决此编译错误，如果返回此字段的任意值即可满足需求，可以使用sqala提供的<code>anyValue</code>聚合函数：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>a <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> a<span class="token punctuation">.</span>x <span class="token operator">+</span> a<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> anyValue<span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>在投影之前可以使用<code>having</code>过滤聚合出的数据：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> p<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>having<span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>name <span class="token operator">=</span> g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birthday <span class="token operator">=</span> max<span class="token punctuation">(</span>p<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>除了简单的分组外，我们可以使用<code>groupByCube</code>和<code>groupByRollup</code>来生成多维分组：</p> <div class="language-scala extra-class"><pre class="language-scala"><code>queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupByCube<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> p<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>name <span class="token operator">=</span> g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupByRollup<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> p<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>name <span class="token operator">=</span> g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>需要注意：MySQL数据库暂未支持<code>GROUP BY CUBE</code>操作。</strong></p> <p>在投影中我们可以使用<code>grouping</code>表达式来辅助多维分组使用：</p> <div class="language-scala extra-class"><pre class="language-scala"><code>queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupByCube<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> p<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>name <span class="token operator">=</span> g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> g1 <span class="token operator">=</span> grouping<span class="token punctuation">(</span>g<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> gender <span class="token operator">=</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> g2 <span class="token operator">=</span> grouping<span class="token punctuation">(</span>g<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>我们也可以使用<code>groupBySets</code>手动指定多维分组，对应到SQL的<code>GROUPING SETS</code>：</p> <div class="language-scala extra-class"><pre class="language-scala"><code>queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupBySets<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> p<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">(</span>g <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>name <span class="token operator">=</span> g<span class="token punctuation">.</span>name<span class="token punctuation">,</span> gender <span class="token operator">=</span> g<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><code>groupBySets</code>的第一个函数参数指定基础分组信息，第二个函数参数把基础分组转换到多维分组，其中空分组使用<code>()</code>指定。</p> <h2 id="distincton分组"><a href="#distincton分组" class="header-anchor">#</a> distinctOn分组</h2> <p>在MySQL中，我们时常会写出如下形式的SQL：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> a<span class="token punctuation">,</span> b <span class="token keyword">FROM</span> t <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> a
</code></pre></div><p>其中<code>b</code>返回任意一个值即可满足需求，但是这样的查询并不符合SQL标准，将此查询迁移到其他数据库时将会是语义错误。</p> <p>因此我们可以使用标准的聚合函数<code>ANY_VALUE</code>来改写：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> a<span class="token punctuation">,</span> ANY_VALUE<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">FROM</span> t <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> a
</code></pre></div><p>转换到sqala中的写法为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>T<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>t <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> t<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>a<span class="token punctuation">,</span> any_value<span class="token punctuation">(</span>t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>但对于这样的未分组列返回随机值即可满足需求的场景，未免有些繁琐，因此sqala效仿PostgreSQL数据库的<code>DISTINCT ON</code>子句，使用<code>distinctOn</code>开启特殊分组，可以将上面的查询简化为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>T<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>distinctOn<span class="token punctuation">(</span>t <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> t<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>a<span class="token punctuation">,</span> t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>在<code>distinctOn</code>分组的<code>map</code>中，未分组的字段在生成SQL时都会统一使用<code>ANY_VALUE</code>，而不会生成错误查询，也无需数据库本身支持<code>DISTINCT ON</code>功能。</p> <h2 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h2> <p>在投影后，我们可以使用<code>sortBy</code>方法进行排序，参数是表达式的排序规则或其组成的元组，多个<code>sortBy</code>会依次拼接：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>sortBy<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">.</span>desc<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>sortBy<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span>asc<span class="token punctuation">)</span>
</code></pre></div><p>其生成的SQL（以MySQL方言为例）形如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>gender<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>id_number<span class="token punctuation">`</span></span>
<span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>people<span class="token punctuation">`</span></span> <span class="token keyword">AS</span> <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">ASC</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">DESC</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>p<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span> <span class="token keyword">ASC</span>
</code></pre></div><p>支持的排序规则有：</p> <table><thead><tr><th style="text-align:center;">排序规则</th></tr></thead> <tbody><tr><td style="text-align:center;"><code>asc</code></td></tr> <tr><td style="text-align:center;"><code>desc</code></td></tr> <tr><td style="text-align:center;"><code>ascNullsFirst</code></td></tr> <tr><td style="text-align:center;"><code>ascNullsLast</code></td></tr> <tr><td style="text-align:center;"><code>descNullsFirst</code></td></tr> <tr><td style="text-align:center;"><code>descNullsLast</code></td></tr></tbody></table> <p>如果直接使用表达式，而不显式写出排序规则，sqala会使用<code>ASC</code>填充。</p> <p>在生成MySQL等数据库方言时，会特殊处理含有<code>NULLS</code>的排序规则，不会生成错误的SQL。</p> <p><strong><code>sortBy</code>不会改变查询结果类型</strong></p> <h2 id="去重"><a href="#去重" class="header-anchor">#</a> 去重</h2> <p>使用<code>distinct</code>方法来对结果集进行去重：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>distinct
</code></pre></div><p><strong>需要注意的是，如果去重查询使用了排序，为了防止生成错误的查询，如果排序的表达式不在投影表达式中，在生成SQL时会将此排序删除：</strong></p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>sortBy<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>distinct
</code></pre></div><p>上文中对于<code>id</code>字段的排序会被sqala删除，仅保留<code>name</code>字段排序。</p> <h2 id="子查询"><a href="#子查询" class="header-anchor">#</a> 子查询</h2> <p>数据库通常支持三种子查询：</p> <div class="language- extra-class"><pre><code>1. `WHERE`和`ON`等子句中的谓词子查询；
2. `FROM`和`JOIN`中的表子查询；
3. `SELECT`子句中的标量子查询。
</code></pre></div><p>sqala对以上子查询均进行了支持。</p> <h3 id="谓词子查询"><a href="#谓词子查询" class="header-anchor">#</a> 谓词子查询</h3> <p>首先是<code>IN</code>、<code>ANY</code>、<code>ALL</code>、<code>EXISTS</code>等语义的子查询：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q1 <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token operator">:</span> a <span class="token keyword">=&gt;</span>
        a<span class="token punctuation">.</span>x<span class="token punctuation">.</span>in<span class="token punctuation">(</span>query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> q1 <span class="token operator">=</span> queryContext<span class="token operator">:</span> 
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token operator">:</span> a <span class="token keyword">=&gt;</span>
        a<span class="token punctuation">.</span>x <span class="token operator">==</span> any<span class="token punctuation">(</span>query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> q1 <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token operator">:</span> a <span class="token keyword">=&gt;</span>
        a<span class="token punctuation">.</span>x <span class="token operator">!=</span> all<span class="token punctuation">(</span>query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> q1 <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token operator">:</span> a <span class="token keyword">=&gt;</span>
        exists<span class="token punctuation">(</span>query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>以上类型的子查询除了<code>exists</code>外，均需要投影到与外侧表达式类型相符。</p> <p>不使用以上语义的子查询：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q1 <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token operator">:</span> a <span class="token keyword">=&gt;</span>
        a<span class="token punctuation">.</span>x <span class="token operator">==</span> query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>take<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> q2 <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token operator">:</span> a <span class="token keyword">=&gt;</span>
        a<span class="token punctuation">.</span>x <span class="token operator">&gt;</span> query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> sum<span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>以上类型的子查询，除了需要与外侧表达式类型相符外，还有一个额外的限制，sqala必须检测到子查询仅返回一行数据，才能通过编译。</p> <p>sqala从以下两种条件中判断子查询返回了一行数据：</p> <div class="language- extra-class"><pre><code>1. 子查询调用了`take(1)`；
2. 子查询在没有调用`groupBy`的情况下，在`map`中仅返回聚合函数。
</code></pre></div><h3 id="表子查询"><a href="#表子查询" class="header-anchor">#</a> 表子查询</h3> <p>sqala支持将子查询放入表连接中，使用表子查询的前提是子查询<strong>投影到了命名元组</strong>，此时我们可以使用<code>.</code>来调用子查询的字段：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>leftJoin<span class="token punctuation">(</span>
        query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> b<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> b<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>x <span class="token operator">==</span> q<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
</code></pre></div><p><code>join</code>和<code>leftJoin</code>子查询支持使用外侧表的字段：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>leftJoin<span class="token punctuation">(</span>a <span class="token keyword">=&gt;</span>
        query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>z <span class="token operator">&gt;</span> b<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> b<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> b<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>x <span class="token operator">==</span> q<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
</code></pre></div><p><strong>这是使用数据库的LATERAL功能实现的，使用时请注意数据库版本是否支持此功能。</strong></p> <p><code>query</code>方法支持将一个返回<strong>命名元组</strong>的查询嵌套为子查询：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> query<span class="token punctuation">(</span>query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>a <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> a<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> a<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>此方法可以将<code>UNION</code>等查询转变为子查询，从而使用<code>SELECT</code>语句独有的过滤、分组等功能。</p> <h3 id="标量子查询"><a href="#标量子查询" class="header-anchor">#</a> 标量子查询</h3> <p>子查询可以使用<code>map</code>放到投影结果中，前提是：</p> <div class="language- extra-class"><pre><code>1. 子查询仅返回一行数据，判断规则与谓词中的子查询一致；
2. 子查询仅返回一列数据，需要使用`map`投影到单个字段。
</code></pre></div><p>符合以上规则的子查询可以放入<code>map</code>列表中：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>a <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">,</span> query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> sum<span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="更好的可读性"><a href="#更好的可读性" class="header-anchor">#</a> 更好的可读性</h3> <p>由于查询放在<code>queryContext</code>方法的作用域中，我们可以将非相关子查询单独提取出一个变量，以获取更好的可读性：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    <span class="token keyword">val</span> subQuery <span class="token operator">=</span> query<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>b <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> b<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> b<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>

    query<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">.</span>leftJoin<span class="token punctuation">(</span>subQuery<span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> a<span class="token punctuation">.</span>x <span class="token operator">==</span> q<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
</code></pre></div><h2 id="集合操作"><a href="#集合操作" class="header-anchor">#</a> 集合操作</h2> <p>sqala支持使用<code>union</code>、<code>unionAll</code>、<code>intersect</code>、<code>intersectAll</code>、<code>except</code>、<code>exceptAll</code>等方法来处理集合查询，比如：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    <span class="token keyword">val</span> q1 <span class="token operator">=</span> query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>filter<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">val</span> q2 <span class="token operator">=</span> query<span class="token punctuation">[</span>People<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>filter<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> p<span class="token punctuation">.</span>id <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

    q1 unionAll q2
</code></pre></div><p>由于<code>UNION ALL</code>与集合拼接语义一致，所以上面的<code>unionAll</code>可以简写成<code>++</code>：</p> <div class="language-scala extra-class"><pre class="language-scala"><code>q1 <span class="token operator">++</span> q2
</code></pre></div><p>处于集合操作两侧的查询：</p> <p>如果是单表查询，两个查询的所有字段类型必须相符，返回结果以第一个实体类类型为准</p> <p>如果是投影查询，其返回类型必须列数量一致，且类型一一对应，假如有两个查询，分别返回<code>(Option[Int], String, Option[LocalDate])</code>和<code>(Int, Option[String], LocalDate)</code>，这样的两个查询调用集合操作将会返回<code>(Option[Int], Option[String], Option[LocalDate])</code>。</p> <p>除了第一个查询需要投影到命名元组外，后续的查询可以投影到元组，将这个查询用于子查询时，或接收数据库返回的结果时，字段名以第一个查询为准：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token comment">// 作为子查询时字段为id和name</span>
<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    <span class="token keyword">val</span> q1 <span class="token operator">=</span> query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> q2 <span class="token operator">=</span> query<span class="token punctuation">[</span>People<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>p <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    q1 union q2
</code></pre></div><h2 id="从内存集合创建查询"><a href="#从内存集合创建查询" class="header-anchor">#</a> 从内存集合创建查询</h2> <p>使用<code>query</code>方法从内存中的集合创建查询，此查询可以使用投影过滤等操作，并可以与其他查询进行<code>join</code>或<code>union</code>等操作：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">case</span> <span class="token keyword">class</span> Entity<span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span>Entity<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;小黑&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Entity<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;小白&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> q <span class="token operator">=</span> query<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>e <span class="token keyword">=&gt;</span> e<span class="token punctuation">.</span>id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>此功能使用数据库的<code>VALUES</code>语句实现，使用时请注意当前数据库版本是否支持此语法。</strong></p> <h2 id="函数表"><a href="#函数表" class="header-anchor">#</a> 函数表</h2> <p>sqala支持函数表语法，我们以PostgreSQL的<code>generate_series</code>函数表为例，创建一个函数表并引入查询。</p> <p>首先需要创建一个函数表的结构，与数据实体类配置类似。</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">case</span> <span class="token keyword">class</span> GenerateSeries<span class="token punctuation">(</span>generateSeries<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>
</code></pre></div><p>然后使用<code>@sqlFunctionTable</code>注解创建一个函数表：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token annotation punctuation">@sqlFunctionTable</span>
<span class="token keyword">def</span> generateSeries<span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> e<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> GenerateSeries <span class="token operator">=</span> compileTimeOnly
</code></pre></div><p>这样就可以将函数表引入查询中了：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">(</span>generateSeries<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>s <span class="token keyword">=&gt;</span> s<span class="token punctuation">.</span>generateSeries <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span>
</code></pre></div><p>我们也可以重载一个创建时间序列的函数表：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token annotation punctuation">@table</span><span class="token punctuation">(</span><span class="token string">&quot;generate_series&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> TimeGenerateSeries<span class="token punctuation">(</span>generateSeries<span class="token operator">:</span> LocalDateTime<span class="token punctuation">)</span>

<span class="token annotation punctuation">@sqlFunctionTable</span>
<span class="token keyword">def</span> generateSeries<span class="token punctuation">(</span>s<span class="token operator">:</span> LocalDateTime<span class="token punctuation">,</span> e<span class="token operator">:</span> LocalDateTime<span class="token punctuation">,</span> i<span class="token operator">:</span> TimeInterval<span class="token punctuation">)</span><span class="token operator">:</span> TimeGenerateSeries <span class="token operator">=</span> 
    compileTimeOnly

<span class="token keyword">import</span> <span class="token namespace">scala<span class="token punctuation">.</span>language<span class="token punctuation">.</span>postfixOps</span>

<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">(</span>generateSeries<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">timestamp</span><span class="token string">&quot;2020-01-01&quot;</span></span><span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token id function">timestamp</span><span class="token string">&quot;2020-02-01&quot;</span></span><span class="token punctuation">,</span> interval<span class="token punctuation">(</span><span class="token number">1</span> day<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="递归查询"><a href="#递归查询" class="header-anchor">#</a> 递归查询</h2> <p>回想一下前文中表连接部分提到的部门表，如果我们想查询一整个部门树，可能需要发出多次查询，但sqala借鉴了Oracle方言的<code>CONNECT BY</code>功能，使用<code>connectBy</code>方法创建递归查询，而无需发出多次查询浪费数据库性能，在生成SQL时会将其转换为SQL标准的<code>CTE(Common Table Expression)</code>查询，而无需数据库本身支持<code>CONNECT BY</code>：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>Department<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>connectBy<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> prior<span class="token punctuation">(</span>d<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>startWith<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>managerId <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">,</span> managerId <span class="token operator">=</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">,</span> name <span class="token operator">=</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><code>connectBy</code>用于创建递归连接条件，其中的<code>prior</code>用于引用递归查询列，具体规则请参考Oracle文档。</p> <p><code>startWith</code>用于创建递归起始条件。</p> <p><code>sortSiblingsBy</code>方法用于指定<strong>每层</strong>的排序规则，而<code>sortBy</code>用于指定总的排序规则：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>Department<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>connectBy<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> prior<span class="token punctuation">(</span>d<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>startWith<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>managerId <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>sortSiblingsBy<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">,</span> managerId <span class="token operator">=</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">,</span> name <span class="token operator">=</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><code>maxDepth</code>用于指定最大的递归层数：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>Department<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>connectBy<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> prior<span class="token punctuation">(</span>d<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>startWith<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>managerId <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>sortSiblingsBy<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">,</span> managerId <span class="token operator">=</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">,</span> name <span class="token operator">=</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>查询结果和排序中可以使用<code>level()</code>伪列，用于统计层级，计数从1开始：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>Department<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>connectBy<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> prior<span class="token punctuation">(</span>d<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>startWith<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>managerId <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>sortSiblingsBy<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">,</span> managerId <span class="token operator">=</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">,</span> name <span class="token operator">=</span> d<span class="token punctuation">.</span>name<span class="token punctuation">,</span> level <span class="token operator">=</span> level<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>我们也可以使用<code>withRecursive</code>方法手动创建递归查询：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> cte <span class="token operator">=</span> queryContext <span class="token punctuation">{</span>
    <span class="token keyword">val</span> baseQuery <span class="token operator">=</span> query<span class="token punctuation">[</span>Department<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>filter<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> d<span class="token punctuation">.</span>managerId <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>map<span class="token punctuation">(</span>d <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">,</span> managerId <span class="token operator">=</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">,</span> name <span class="token operator">=</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

    withRecursive<span class="token punctuation">(</span>baseQuery<span class="token punctuation">)</span><span class="token operator">:</span> q <span class="token keyword">=&gt;</span>
        <span class="token keyword">val</span> unionQuery <span class="token operator">=</span> query<span class="token punctuation">[</span>Department<span class="token punctuation">]</span>
            <span class="token punctuation">.</span>join<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            <span class="token punctuation">.</span>on<span class="token operator">:</span> <span class="token punctuation">(</span>d<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
                d<span class="token punctuation">.</span>managerId <span class="token operator">==</span> tmp<span class="token punctuation">.</span>id
            <span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">,</span> managerId <span class="token operator">=</span> d<span class="token punctuation">.</span>managerId<span class="token punctuation">,</span> name <span class="token operator">=</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
            
        q <span class="token operator">++</span> unionQuery
<span class="token punctuation">}</span>
</code></pre></div><h2 id="透视表"><a href="#透视表" class="header-anchor">#</a> 透视表</h2> <p>在数据分析场景中，行转列透视表通常使用聚合函数配合<code>CASE WHEN</code>表达式构建，sqala也自然支持此类写法：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">case</span> <span class="token keyword">class</span> City<span class="token punctuation">(</span>population<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> year<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> country<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>City<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>map<span class="token operator">:</span> c <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>
                total_2000 <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token keyword">if</span> c<span class="token punctuation">.</span>year <span class="token operator">==</span> <span class="token number">2000</span> then c<span class="token punctuation">.</span>population <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                total_2001 <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token keyword">if</span> c<span class="token punctuation">.</span>year <span class="token operator">==</span> <span class="token number">2001</span> then c<span class="token punctuation">.</span>population <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                count_2000 <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token keyword">if</span> c<span class="token punctuation">.</span>year <span class="token operator">==</span> <span class="token number">2000</span> then Some<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">else</span> None<span class="token punctuation">)</span><span class="token punctuation">,</span>
                count_2001 <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token keyword">if</span> c<span class="token punctuation">.</span>year <span class="token operator">==</span> <span class="token number">2001</span> then Some<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">else</span> None<span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
</code></pre></div><p>但我们也可以使用<code>pivot</code>来更简便地创建行转列透视表：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>City<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>pivot<span class="token punctuation">(</span>c <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>total <span class="token operator">=</span> sum<span class="token punctuation">(</span>c<span class="token punctuation">.</span>population<span class="token punctuation">)</span><span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>`<span class="token keyword">for</span>`<span class="token operator">:</span> c <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>
                c<span class="token punctuation">.</span>year<span class="token punctuation">.</span>within<span class="token punctuation">(</span>`<span class="token number">2000</span>` <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> `<span class="token number">2001</span>` <span class="token operator">=</span> <span class="token number">2001</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
</code></pre></div><p>在<code>pivot</code>中指定若干个聚合函数，在<code>for</code>中使用<code>within</code>指定若干个投影列，sqala将会自动将其转换为<code>SUM(CASE WHEN ...)</code>形式的查询，无需数据库本身支持<code>PIVOT</code>子句；并将<code>pivot</code>和<code>for</code>中的命名元组字段名组合作为新的返回字段名，上面查询的返回类型为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> 
    List<span class="token punctuation">[</span>
        <span class="token punctuation">(</span>
            total_2000 <span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
            total_2001 <span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
            count_2000 <span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> 
            count_2001 <span class="token operator">:</span> <span class="token builtin">Long</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">]</span> <span class="token operator">=</span> 
        db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div><p>如果<code>for</code>中指定了其他表达式：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> q <span class="token operator">=</span> queryContext<span class="token operator">:</span>
    query<span class="token punctuation">[</span>City<span class="token punctuation">]</span>
        <span class="token punctuation">.</span>pivot<span class="token punctuation">(</span>c <span class="token keyword">=&gt;</span> <span class="token punctuation">(</span>total <span class="token operator">=</span> sum<span class="token punctuation">(</span>c<span class="token punctuation">.</span>population<span class="token punctuation">)</span><span class="token punctuation">,</span> count <span class="token operator">=</span> count<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>`<span class="token keyword">for</span>`<span class="token operator">:</span> c <span class="token keyword">=&gt;</span>
            <span class="token punctuation">(</span>
                c<span class="token punctuation">.</span>year<span class="token punctuation">.</span>within<span class="token punctuation">(</span>`<span class="token number">2000</span>` <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> `<span class="token number">2001</span>` <span class="token operator">=</span> <span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                c<span class="token punctuation">.</span>country<span class="token punctuation">.</span>within<span class="token punctuation">(</span>cn <span class="token operator">=</span> <span class="token string">&quot;CN&quot;</span><span class="token punctuation">,</span> us <span class="token operator">=</span> <span class="token string">&quot;US&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
</code></pre></div><p>则返回类型为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> result<span class="token operator">:</span> 
    List<span class="token punctuation">[</span>
        <span class="token punctuation">(</span>
            total_2000_cn <span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
            total_2000_us <span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
            total_2001_cn <span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
            total_2001_us <span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
            count_2000_cn <span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> 
            count_2000_us <span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> 
            count_2001_cn <span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> 
            count_2001_us <span class="token operator">:</span> <span class="token builtin">Long</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">]</span> <span class="token operator">=</span> 
        db<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sqala-doc/database/" class="prev">
        数据库交互
      </a></span> <span class="next"><a href="/sqala-doc/native-query/">
        原生SQL
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sqala-doc/assets/js/app.96be3cda.js" defer></script><script src="/sqala-doc/assets/js/2.767acac5.js" defer></script><script src="/sqala-doc/assets/js/1.7485bcf3.js" defer></script><script src="/sqala-doc/assets/js/31.25a10860.js" defer></script>
  </body>
</html>
